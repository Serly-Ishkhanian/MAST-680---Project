# -*- coding: utf-8 -*-
"""Dyanmics_project .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14WkwK5DlFl7vvH58EtA2b1lsWjfR0b0i
"""

import numpy as np 
import cv2 
import time
from matplotlib import pyplot as plt
from matplotlib import pyplot as plt
from PIL import Image

pip install scikit-video

import skvideo.io

"""#The QB decompsoition function """

def randomized(m, s,q,p):

  l = s + p
  n = m.shape[1]

  omega = np.random.normal(0, 1, size=(n, l))

  Z = m @ omega 

  for k in range(q):

    Z = m @(m.T @Z)

  Q,R = np.linalg.qr(Z)
  B = Q.T @ m

  return Q,B

"""#SVD- Data projection"""

def low_rank_approximation(number_of_singularvalues):

  # Compute the projected data 
  new_matrix = u[:,0:number_of_singularvalues].conj().T @ Transpose_frames

  return new_matrix

"""#Experiment 1"""

# Upload image
image = cv2.imread('/content/JFeEHc.jpg')

# Read image
image_data = image.copy()

# Get image size
image.shape

# Convert to grayscale 
gray_image = cv2.cvtColor(image_data, cv2.COLOR_BGR2GRAY)

#plot the approximated image and the difference bwteen approximated and original

def plot(f1, new_matrix, s) :
   
  reduced_frame = np.reshape(f1,(2160,3840))

  fig, (ax1, ax2) = plt.subplots(1, 2,figsize=(10,8))
  ax1.imshow(reduced_frame,cmap='gray')
  ax1.set_title("Low Rank Approximation (s="+str(s)+")")
  ax2.imshow(np.reshape(gray_image-f1,(2160, 3840)),cmap='gray')
  ax2.set_title(" Difference ")

 
  plt.show()

plt.imshow(gray_image,cmap='gray')
plt.title("Original Image")

"""The SVD"""

start = time.time()
f1, new_matrix = low_rank_image_reconstruction(300)
end = time.time()

# Compute time it took 
final = end-start


# Plot the reconstructed image
plot(f1,new_matrix,300)

print("\nTime it took to compute the low rank approximation: ", final,"seconds")

"""Randomized method """



"""Case: s=300, q=0, p=0"""

start_time = time.time()

Q1,B = randomized(gray_image,300,0,0)

end_time = time.time()
final_time = end_time - start_time
print(final_time)

plot(Q1@B,Q1.T@gray_image,300)

"""Case: s=300, q=0, p=10"""

start_time = time.time()

Q1,B = randomized(gray_image,300, 0,10)

end_time = time.time()
final_time = end_time - start_time
print(final_time)

plot(Q1@B,Q1.T@gray_image,300)

"""Case: s=300, q=1, p=10"""

start_time = time.time()

Q1,B = randomized(gray_image,300,1,10)

end_time = time.time()
final_time = end_time - start_time
print(final_time)

plot(Q1@B,Q1.T@gray_image,300)

"""  Case: s=300, q=2, p=10"""

start_time = time.time()

Q1,B = randomized(gray_image,300,2,10)

end_time = time.time()
final_time = end_time - start_time
print(final_time)

plot(Q1@B,Q1.T@gray_image,300)

"""# Block Randomized Algorithm

"""

b  = int(2160/4)
s=300
q=1
p=10
D1 = gray_image[:b,:]
D2 = gray_image[b:2*b,:]
D3 = gray_image[2*b:3*b,:]
D4 = gray_image[3*b:4*b,:]

# Approximate each block 
rstart_time1 = time.time()
Q1,B1 = randomized(D1,s,q,p)
Q2,B2 = randomized(D2,s,q,p)
Q3,B3 = randomized(D3,s,q,p)
Q4,B4 = randomized(D4,s,q,p)


K = np.vstack((B1,B2,B3,B4))
Qhat,B = randomized(K,s,q,p)

rend_time1 = time.time()

rfinal_time1 = rend_time1 - rstart_time1
print(rfinal_time1)

# Create the block diagonal matrix
n = gray_image.shape[1]
I = np.zeros((540,s+p))

Q = np.block([[Q1,I,I,I],[I,Q2,I,I],[I,I,Q3,I],[I,I,I,Q4]])@Qhat
Q.shape

plot(Q@B,Q.T@gray_image,300,10)

"""# Experiment 2"""

videodata = skvideo.io.vread("/content/ski_drop_low.mp4")

# Get dimensions 
number_of_frames, height, width, colors = videodata.shape

# Convert to greyscale 
grey_ski = skvideo.utils.rgb2gray(videodata)

# Create a 2D data matrix 
frames = [] 

for frame in grey_ski:

  #Vectorize the frames by stacking the columns vertically 
  reshaped_frame = frame.reshape((540*960))  

  frames.append(reshaped_frame)        #adds them to the matrix "frames" as rows 



# Transpose the matrix frames so that the each column represents a frame and dimension becomes space x time 
Transpose_frames = np.array(frames).T

start = time.time()
u,s,vh = np.linalg.svd(Transpose_frames,full_matrices = False)
end = time.time()

final= end-start 
print("Time it took : ", final ," seconds.")

# Projected Matrix for the SVD
start1 = time.time()

D30 = low_rank_approximation(30)
end1 = time.time()
final1 = end1-start1

print("Time it took : ", final1 ," seconds.")

total = final +final1 

print("Total time to project data onto a lower-dimensional space using the SVD is:",total, "seconds." )

"""Case s=30,p=5,q=0 """

rstart_time = time.time()

Q0,B0 = randomized(Transpose_frames,30,0,5)
rend_time = time.time()

rfinal_time = rend_time - rstart_time
print(rfinal_time)

# the low-rank approximation of D
approx= Q0@B0

# Accuracy of the approximation 
plt.imshow(np.reshape(approx[:,425],(height,width)),cmap="gray")

"""Case s=30, q=0, p=10"""

rstart_time = time.time()

Q0,B0 = randomized(Transpose_frames,30,0,10)
rend_time = time.time()

rfinal_time = rend_time - rstart_time
print(rfinal_time)

# the low-rank approximation of D
approx= Q0@B0

# Accuracy of the approximation 
plt.imshow(np.reshape(approx[:,425],(height,width)),cmap="gray")

"""Case s=30, q=1, p=10"""

rstart_time = time.time()

Q0,B0 = randomized(Transpose_frames,30,1,10)
rend_time = time.time()

rfinal_time = rend_time - rstart_time
print(rfinal_time)

# the low-rank approximation of D
approx= Q0@B0


# Accuracy of the approximation 
plt.imshow(np.reshape(approx[:,425],(height,width)),cmap="gray")

"""Case : s=30, p=10, q=2"""

rstart_time = time.time()

Q0, B0 = randomized(Transpose_frames,30,2,10)
rend_time = time.time()

rfinal_time = rend_time - rstart_time
print(rfinal_time)

# the low-rank approximation of D
approx= Q0@B0


# Accuracy of the approximation 
plt.imshow(np.reshape(approx[:,425],(height,width)),cmap="gray")

plt.imshow(np.reshape((u[:,:s] @D30)[:,425],(height,width) ),cmap="gray")

"""#Blocked randomized method"""

# Partition into 4 blocks along the rows
b  = int(518400/4)

D1 = Transpose_frames[:b,:]
D2 = Transpose_frames[b:2*b,:]
D3 = Transpose_frames[2*b:3*b,:]
D4 = Transpose_frames[3*b:4*b,:]

# Approximate each block using the qb decomposition with s=30 , p = 10, q=2
s=30
p=10
q=2
rstart_time1 = time.time()
Q1,B1 = randomized(D1,s,q,p)
Q2,B2= randomized(D2,s,q,p)
Q3,B3 = randomized(D3,s,q,p)
Q4,B4 = randomized(D4,s,q,p)

K = np.vstack((B1,B2,B3,B4))
Qhat, B_block = randomized(K,s,q,p)
rend_time1 = time.time()

rfinal_time1 = rend_time1 - rstart_time1
print(rfinal_time1)

# Create the block diagonal matrix
n = Transpose_frames.shape[1]
I = np.zeros((129600,b*(s+q)))

Q = np.block([[Q1,I,I,I],[I,Q2,I,I],[I,I,Q3,I],[I,I,I,Q4]])@Qhat
Q.shape

# Returns the X, Y matrices and the DMD matrix A
def create_XY(data):
  n = data.shape[1]
  X = np.delete(B0,n-1,axis=1)
  Y = np.delete(B0,0,axis=1)

  A = Y @ np.linalg.pinv(X)

  return X, Y, A

# Create the matrices X and Y for randomized method
X,Y,A_b = create_XY(B0)

# For randomized methods 
# Compute the SVD of X
u,s,vh = np.linalg.svd(X)
A = u.T @A_b @u

# With SVD directly compute 
# Create the matrices X and Y and the DMD Matrix A
X,Y,A = create_XY(D30)

"""# Dimensionality Reduction: Randomized Methods

Case s= 30, q=0, p=0
"""

rstart_time = time.time()

Q0,B0 = randomized(Transpose_frames,30,0,0)

rend_time = time.time()
rfinal_time = rend_time - rstart_time
print(rfinal_time)

# the low-rank approximation of D
approx = Q0@B0

# Accuracy of the approximation 
plt.imshow(np.reshape(approx[:,425],(height,width)),cmap="gray")

#Define 
s = 30
p = 10
l = s+p

# Get eigenvalues and eigenvectors of A
evalues, evectors = np.linalg.eig(A)

# Create omega: continuous time eigenvalues of A
omega =[]               

# duration of video/number of frames
dt =8/number_of_frames    

for eigenvalue in evalues:
  omegak = np.log(eigenvalue)/dt
  omega.append(omegak)

omega = np.array(omega)



"""Plot the discrete time eigenvalues """

plt.scatter(evalues.real,evalues.imag)
plt.xlabel("Re($\mu$)")
plt.ylabel("Im($\mu$)")
plt.title("Plot of Discrete Time Eigenvalues $\mu$",fontsize=11)
plt.show()


"""Plot the continuous time eigenvalues 

(This will be used to determine a threshold to separate the fast and slow ones) """

plt.figure(figsize=(5,5))
plt.xlabel("Re($\omega$)")
plt.ylabel("Im($\omega$)")
plt.title("Plot of Continuous Time Eigenvalues $\omega$",fontsize=11)
plt.scatter((omega).real,(omega).imag)
plt.show()

# Zoomed in 
plt.figure(figsize=(5,5))
plt.xlabel("Re($\omega$)")
plt.ylabel("Im($\omega$)")
plt.title("Continuous Time Eigenvalues $\omega$ : Zoomed-In",fontsize=11)
plt.axis([-0.5,0.5, -0.05, 0.05])    
plt.scatter((omega).real,(omega).imag)
plt.show()


# Find coefficients of the eigendecomposition 
b = np.linalg.pinv(evectors) @ X[:,0]
b.shape


"""Find index of the continuous time eigenvalues that fall below the threshold"""

slow_index = []
for i in range(len(omega)):
  if abs(omega[i])<0.01:
    slow_index.append(i)



"""Create a vector b corresponding to the coefficients of the slow modes that has zeros everywhere except at the position of the slow_index"""

b_slow = np.zeros(b.shape).astype(complex)

for i in slow_index:
  b_slow[i] = b[i]

np.array(slow_index).shape



"""The background (slow_x)"""

slow_x = np.zeros((l,number_of_frames)).astype('complex')

for i in range(number_of_frames):
  for j in range(l):
    if b_slow[j]!=0:
      slow_x[:,i] = slow_x[:,i]+(b[j]* np.exp(omega[j]*i))*evectors[:,j]



"""The foreground (x_sparse)"""

x_sparse = B0 - np.abs(slow_x)




"""Calculate the matrix R """
#Since the above calculation may result in x_sparse having negative values in some of its elements, which would not make sense in terms of having negative pixel intensities. These residual negative values can be put into a nÃ—m matrix R and then be added back into x_slow:

new_r =np.zeros(x_sparse.shape)

for i in range(number_of_frames):
  for j in range(l):
    if x_sparse[j,i].real <0:
      new_r[j,i] = x_sparse[j,i]


# Reassign
new_sparse = x_sparse - new_r

new_slow =np.abs(slow_x) + new_r


#Plot the foreground and background
plt.imshow(np.reshape((Q0@ new_sparse[:,425]),(height, width)),cmap = 'gray')
plt.title("Foreground")
plt.show()

plt.imshow(np.reshape((Q0@ new_slow[:,425]),(height, width)),cmap = 'gray')
plt.title("Background")
plt.show()

# Note: the code "ski_video" can be used to produce the cumulative enrgies and plots of the low-rank approximation using different s values.







